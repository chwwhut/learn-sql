## 【十三章】设计数据库

## 1. 介绍

Introduction (1:25)

之前都是对已有数据库进行查询，这一章学习如何设计和创建数据库（以及表格）。

设计一个结构良好的数据库是需要耗费不少时间和心力的，但这是十分必要的，设计良好的数据库可以快速地查询到想要的数据并且有很好的扩展性（很容易满足新的业务需求），相反，一个设计糟糕的数据库可能需要大量维护且查询又慢又麻烦，Mosh之前的一家公司的数据库就做得很糟糕，有些储存程序有上千行代码而且有些查询执行时间长达数分钟，所以，拥有设计良好的数据库是非常重要的。

这一章将系统性地逐步讲解如何设计一个结构良好的数据库

## 2. 数据建模

这一节讲数据建模，即为想要储存进数据库的数据建立模型的过程，其中包含4步：

1. Understand the requirements 理解需求

第1步是理解和分析商业/业务需求，遗憾是很多程序员跳过了这一步就急着去设计数据库里的表和列了，实际上，这一步是最关键的一步，你对问题理解的越透彻，你才越容易找到最合适的解决方案，设计数据库也一样。所以，在动手创建表和列之前，要先完整了解你的业务需求，包括和产品经理、行业专家、从业人员甚至终端用户深入交流以及收集查阅与该问题领域相关的表、文件、应用程序、数据库，以及其他相关的任何信息或资料

2. Build a conceptional model 概念建模

当收集并理解了所有相关信息后，下一步就是为业务创建一个概念性的模型。这一步包括找出/识别/确认（identify）业务中的 实体/事物/概念（entities/things/concepts）以及它们之间的关系。概念模型只是这些概念的一个图形化表达，用来**与利益相关方交流和达成共识**

3. Build a logical model 逻辑建模

创建好概念模型后，转而创建数据模型（data model）或数据结构（data structure for storing data），即逻辑建模。这一步创建的是不依赖于具体数据库技术的抽象的数据模型，主要是确认所需要的**表和列**以及大体的数据类型

4. Build a physical model 实体建模

实体建模指的是将逻辑模型在具体某种DBMS上加以实现的过程，相比于逻辑模型，实体模型会确定更多细节，包括各表主键的设定，各列在某一DBMS下特定的具体的数据类型，是否有默认值，是否可为空，还包括储存过程和触发器等对象的创建。总之，实体模型是在某一特定DBMS下对数据模型非常具体的实现

以上就是数据建模的流程

下一节将讲解概念模型

## 3. 概念模型

想要建一个销售在线课程的网站，用户可以注册一项或多项课程，课程可以有诸如 "frontend（前端）" "backend（后端）" 这样的标签

对于一个线上课程网站来说，重要的概念/实体有哪些？很容易想到有学生（student）和课程（course）

我们需要一种将实体及其关系可视化的方法，一种是实体关系图（Entity Relationship, ER），一种是统一建模语言（Unified Modeling Language，UML），这里我们用实体关系图（ER），使用的工具是 [http://draw.io](https://link.zhihu.com/?target=http%3A//draw.io)

步骤如下：

1. 建立学生实体并确定相关属性，如姓名、电子邮件、注册时间
2. 建立课程实体并确定相关属性，如课程名、价格、老师、标签
3. 建立两个实体间的关系，暂时先用多对多连线（概念模型里只是画好连线，逻辑建模时再考虑连线的类型），加上 enrolls 标签表示两者间的关系是“学生→注册 →课程”

![img](https://pic1.zhimg.com/80/v2-aab2261da97eb2bb00a3bc6049a73e34_720w.webp)

在线授课网站-概念模型

**注意**

建模是个迭代过程，不可能第一次就建立完美模型，需要在理解需求和模型设计之间不断反复，多次调整。比如这里的学生属性，可以先确定个大概，之后可以根据需要再进行增删修改

**小结**

概念模型主要是从很高的视角来总览业务需求，识别业务中的实体/事物/概念以及他们彼此间的关系，通常这些实体包括人、事件、地点等

这一步暂不考虑数据类型和具体的DBMS这样的技术细节，只是从概念上总揽全局，目的是和业务人员交流，保持理解一致，避免鸡同鸭讲

**导航**

下一节我们将用这个概念模型来建立逻辑模型

## 4. 逻辑模型

接前面线上课程网站的例子，对概念模型逻辑化的过程如下：

1. 细化实体间关系：

考虑学生和课程的关系，首先这是一种多对多关系（通常意味着需要进一步细化），其次了解到业务上有如下需求：

- 需要记录学生注册特定课程的日期
- 课程价格是变化的，需要记录学生注册某门课程时的特定价格

这些属性相对于学生和课程而言都是一对多关系，不管放在学生还是课程身上都不合适，所以，应该为学生和课程之间的关系，即 **注册课程的事件** 本身另外设立一个实体 enrollmemt，上面的注册日期和注册价格都应该是这个 enrollment 注册事件 的属性

2. 调整字段并大体确定字段的数据类型：

姓名（name）最好拆分为姓和名 (first_name 和 last_name)，同理，地址应该拆分为省、市、街道等等小的部分，这样方便查询。注意课程里的 tags 标签字段不是一个好的设计，之后讲归一化时再来处理
这里的数据类型只需确定个大概即可，如：是 string，float 而非 VARCHAR, DECIMAL。等到下一步实体模型里再来确定某个DBMS下的具体数据类型

![img](https://pic3.zhimg.com/80/v2-cf76ce848e98d25d8b83a47ea1a29172_720w.webp)

在线授课网站-逻辑模型

**小结**

逻辑模型是在概念模型的基础上，在不依赖特定数据库系统的前提下确定数据结构，包括**细化实体间的关系（常常要为关系创造新的实体），调整字段设置，确定大体的数据类型。**总之，逻辑模型会基本确立数据库中的**表、列以及表间关系。**

## 5. 实体模型

实体模型就是逻辑模型在具体DBMS的实现，这里我们用MySQL实现前面线上课程网站的逻辑模型

在 **Workbench-file-new model** 新建数据库模型，右键 edit 修改数据库名字为 school

上方用 add diagram 作 EER 图，这里 EER 表示 Enhanced Entity Relationship 增强型实体关系图。为三个实体创建三张表，设定表名、字段、具体的数据类型、是否可为空（即是否为必须字段？），是否有默认值（主键设定之后再讲）。有几个注意点：

- 表名：
  之前逻辑模型里表名用单数，但这里表名用复数。这只是一种惯例，单复数都行，关键是要保持一致。
  如果团队有相关惯例就去遵守它，即便那不够理想，也别去破环惯例，否则**沟通和维护成本会**大大增加，你需要不断去想该用单数还是复数
- 字段名：
  以 enrollments 表为例，注册事件的属性应该是 date日期 和 price价格 而非 enrollment_date注册日期 和 enrollement_price注册价格，不要将表名前缀加上字段上造成不必要的麻烦，保持精简（keep things simple）
- 数据类型：
  数据类型要根据业务需要来，例如，和业务人员确认后发现课程价格最高是999美元，所以 price价格 就可以设定为 DECIMAL(5,2)，之后如果需求变了了也可以随时更改，不要一上来就设定DECIMAL(9,2)，浪费磁盘，注意尽可能节省空间（keep things small）

![img](https://pic3.zhimg.com/80/v2-fc68cc007e5e18cfcd003155a1ed1d8a_720w.webp)

在线授课网站-实体模型

**小结**

实体模型是逻辑模型在特定DBMS上的实现，主要是一些技术上的细化，包括确定字段具体数据类型和性质（能否为空等），设置主键等

**导航**

接下来我们要给每一个表设置一个主键并定义表之间的关系

## 6. 主键

主键就是能唯一标识表中每条记录的字段

**设定 students 表的主键：**

不管是 first_name 还是 last_name 都不能唯一标识每条记录，它们两个合起来作为联合主键也不行，因为两个人全名相同也是可能的（都叫 Tom Smith）。Email 也不适合作主键，首先太长了，之后需要作为外键复制到其他表会很浪费资源，而且 Email 也可能改变。

总之主键要短，可唯一标识记录，且永不改变。我们增加一个 student_id 作为主键，类型设为 INT（最大可表示2亿，一般足够了，但记得总是根据具体的需求决定），设为主键后自动变为不可为空，另外还要设定 AI（Auto Incremental）自动递增，这样会方便许多，不要担心主键唯一性的问题，最后我们把主键拖到表的第一列让表的结构看起来更清晰

**设定 courses 表的主键：**

增加一个 course_id 作为主键，其它和 student_id 一样

**导航**

下节课讲 enrollemnts 表的主键问题

## 7. 外键

注意 enrollments 表的特殊性，它可以说是 students 和 courses 的衍生表，先要有学生和课程，才能有 学生注册课程 这一事件，后者表述的是前两者的关系，学生和课程是因，注册课程这一事件是果

MySQL里可以通过一对一或一对多两种连线表达这种先后关系/因果关系并自动建立外键，其中学生和课程被称作父表或主键表，注册事件被称作子表或外键表，外键是子表里对父表主键的引用

几个细节：

- 连线时记不得先连主表还是子表可以看状态栏的提示
- MySQL自动添加的外键会带父表前缀，没必要，建议去掉

可以看到，相对于逻辑模型，实体模型有更多实现细节，包括设置字段具体类型和性质以及根据表间关系确定主键和外键

现在，根据表间关系给 enrollments 表添加了 student_id 和 course_id 两个外键，enrollments 的主键设置有两个选择：

1. 将这两个外键作为联合主键
2. 另外设置一个单独的主键 enrollment_id

两种选择各有优缺点，以联合主键为例：

- 好处是可以避免重复的注册记录，即可以防止同一个学生重复注册同一门课程，因为主键（这里是联合主键）是唯一不可重复的，这可以防止一些不合理的数据输入
- 坏处是如果 enrollments 未来有新的子表，就需要复制两个字段（而不是 enrollment_id 一个字段）作为外键，这也不一定是很大的麻烦，要根据数据量以及子表是否还有子表等情况来考虑，在一定情况下可能会造成不必要冗余和麻烦

但目前来说，没有为 enrollments 建立子表的需求，**永远不要为未来不知道会不会出现的需求进行设计开发**，如果之后需要的话也可以通过脚本修改表结构，也不会很麻烦，所以目前的情况，用联合主键就好了。在 enrollments 表里把两个外键的黄钥匙都点亮，即成为联合主键

![img](https://pic1.zhimg.com/80/v2-e708ee7d0eec0615a4e21034913f9c9c_720w.webp)

父子表、主键与外键

## 8. 外键约束

Foreign Key Constraints (5:22)

有外键时，需要设置约束以防止数据损坏/污染（不一致）

在 enrollements 表设计模式里，打开 Foreign Keys 标签页，可以看到两个外键，以 `fk_子表_父表` 的方式命名，名称后可能有数字，是MySQL为了防止外键与其他外键重名自动添加的，这里没必要，可去掉。右边 Foreign Key Options 可分别选择当父表里的主键被修改或删除（Update / Delete）时，子表里的外键如何反应，有三种选项：

1. CASCADE:
   瀑布/串联/级联，表示随着主键改变而改变，如主键某学生的 student_id 从1变成2，则该学生的所有注册课程记录的 student_id 也会全部变为2 （注意主键一般也最好是永远不要变的，这里讨论的是特殊情况）
2. RESTRICT / NO ACTION:
   两者等效，作用都是禁止更改或删除主键。如：对于有过注册记录的课程，除非先删除该课程的注册购买记录，不然不能在 courses表 里删除该课程的信息
3. SET NULL:
   就是当主键更改或删除时，使得相应的外键变为空，这样的子表记录就没有对应的主键和对应的父表记录了（no parent），被称为孤儿记录（orphan record），这是垃圾数据，让我们不知道是谁注册的课程或不知道注册的是什么课程，一般不用，只在极其特殊的情况可能有用。

**经验法则**

通常对于 UPDATE, 设置为 CASCADE 级联，随之改变

对于 DELETE，看情况而定，可能设置为 CASCADE 随之删除 也可能设置为 RESTRICT / NO ACTION 禁止删除。不要死板，**永远按照业务/商业需求来选择**，这也正是为什么之前强调“理解业务需求”是最重要的一步。比如我们课程注册记录里包含购买价格信息，则应该禁止删除，否则之后想统计某课或某时间段收入信息就会缺数据，相反如果只是个用户登录并设定一系列提醒的软件，可能允许用户注销并删除所有提醒就没什么大不了的，但万一我们需要这些提醒记录来进行统计，那又应该设置为禁止删除，总之一定要根据具体业务需求来（always check with the business）

## 9. 数据库规范化/正规化/归一化

正式建立数据库前我们先要检查并确定现在的设计是最优化的（optimal），关键是没有任何冗余或重复。重复数据会占用更多空间并且使得增删查改的操作复杂化，比如，如果用户名在多处出现的话，一旦更改用户名就要到多处更改否则就会使得数据不一致，出现无效数据。

为了防止重复冗余，需要遵循数据库设计的7大规则或者说7大范式，每一条都是建立在你已经遵循了前一条的基础上。实际上，99%的数据库之需要遵循**前三大范式**就够了，其他几个并没有那么重要。接下来将依次讲解前三大范式并给出可操作的建议，让你能够在不死记硬背这些规则的情况下轻松设计出归一化的数据库

补充：维基百科——数据库规范化

> 数据库规范化，又称正规化、标准化，是数据库设计的一系列原理和技术，**以减少数据库中数据冗余，增进数据的一致性。**关系模型的发明者埃德加·科德最早提出这一概念，并于1970年代初定义了第一范式、第二范式和第三范式的概念，还与Raymond F. Boyce于1974年共同定义了第三范式的改进范式——BC范式。
> 除外还包括针对多值依赖的第四范式，连接依赖的第五范式、DK范式和第六范式。
> 现在数据库设计最多满足3NF，普遍认为范式过高，虽然具有对数据关系更好的约束性，但也导致数据关系表增加而令数据库IO更易繁忙，原来交由数据库处理的关系约束现更多在数据库使用程序中完成。

## 10. 第一范式

**第一范式：**

> Each cell should have a single value and we cannot have repeated columns.
> 每个单元格都应该是单一值并且不能有重复的列

courses 里的 tags 标签列就不符合第一范式。tags 列用逗号隔开多个标签，不是单一值。若将 tags 分割成多列，每个标签一列呢？问题是我们不知道到底有多少标签，每次出现新标签就要改动表结构，这样的设计很糟糕。这也正是范式1要求没有重复列的原因（没有重复列是这个意思？我还以为重复列是指在多表出现相同列（如姓名列）的情况）

所以我们另外单独创建一个 tags 表，设置两个字段：

1. tag_id TINYINT 如果标签是终端用户设定的，那数量就可能会迅速增长，但这里假定标签是管理员设定的，最多可能五六十个，那 TINYINT 足够了
2. name VARCHAR(50)

**导航**

下节课我们将在 tags 与 courses 间建立多对多关系

## 11. 链接表

Link Tables (4:01)

尝试建立 courses 和 tags 之间的联系，发现两者是多对多关系（MySQL里只有一对一和一对多，没有多对多），这说明两者的关系需要进一步细化，我们添加一个 course_tags 表来专门描述两者间的关系，记录每一对课程和标签的组合，这个中间表或者说**链表（link table）**同时是 courses 和 tags 的子表，与这两个父表均为一对多的关系，建立两条一对多连线后 MySql 自动给 course_tags 表增加了两个外键 course_id 和 tag_id（注意去掉自动添加的表前缀），两者构成了 course_tags 表 的联合主键

![img](https://pic4.zhimg.com/80/v2-b5952a087838ce71edcc29aa8cd83043_720w.webp)

courses 和 tags 之间的链表 course_tags

通过 course_tags 细化 courses 和 tags 的关系 与 之前通过 enrollments 表细化 students 和 courses 的关系一样，都是**通过建立链表细化多对多关系**，这是很常用的一种方法，有时链表只包含引用的两个外键，如 course_tags 表，有时链表还包含其它信息，如 enrollments 表还包含注册时间和注册费用

至此，删除掉 courses 里的 tags 列，我们的数据库就符合第一范式了，所有列都是单一值也没有诸如tag1，tag2这样的重复列，所有标签都保存在独立的 tags 表里拥有唯一记录。如果像之前那样标签以逗号分隔保存在 courses 表中，同一个标签如 "frontend" 会多次出现，如果要将这个标签改名为 "front-end" 就会多出很多不必要的锁定操作，修改标签却要锁定 courses 表里的记录，这本身就很不合理，tags 表才该是唯一储存标签的地方，而tags 里的标签条目才是修改标签时唯一应该被锁定的条目

**导航**

接下来讲第二范式

## 12. 第二范式

**第二范式的人话解释：**

> Every table should describe one entity, and every column in that table should describe that entity.
> 每个表都应该是单一功能的/应该表示一个实体类型，这个表的所有字段都是用来描述这个实体的

以 courses 表为例，course_id、title、price 都完全是属于课程的属性，放在 courses 表里没问题，但注册时间 enrollment_date 放在 courses 表里就不合适，因为一个课程可以被多个学生注册所以有多个注册时间，同样的注册时间也不应该是 students 表的属性，因为一个学生可以注册多门课所以可以有多个注册时间，注册时间应该是属于“注册事件”的属性，所以应该另外建个 enrollments 表，放在该表里。

同理，对于订单表 orders 来说，order_id 和 date 应该是其中的属性，但 customer 就不是，虽然每个订单确实有对应的顾客，但顾客信息可能在不同订单里重复，这会占用多余的储存空间并使得修改变得困难，应该单独建一个顾客表来储存顾客信息，订单表里用顾客id而非顾客名来引用顾客表，当然，顾客id还是会重复，但4字节的数字比字符串占用的空间小多了，这已经是让重复最小化了

总之，第一范式是要求单一值和无重复列，这里第二范式是要求表中所有列都只能是完全描述该表所代表的实体的属性，不属于该实体的、在记录中可重复的属性（如订单表里的顾客信息），应该另外放在描述相应实体的表里（顾客表）

以我们这个模型为例，courses 里的 instructors 虽然是单一值符合第一范式却不符合第二范式，因为老师不是完全属于课程的属性，老师在不同课程中可能重复。所以，另外建立 instructrors 表作为父表，包含 instructor_id 和 name 字段，其中 instructor_id 为主键，一对多链接 courses 表后自动引进 courses 表作为外键，删除原先的 instructor 列。还有注意设置外键约束，UPDATE 设置为 CASCADE，DELETE 设置为 NO ACTION，也就是 instructor_id 会随着 instructors 表更改，但不允许在某教师有课程的情况下删除该教师的信息

至此，我们的数据库已符合第二范式。

![img](https://pic3.zhimg.com/80/v2-e7296e49a86ea8d06257701f14ba88ea_720w.webp)

courses 的查询表/资料表 instructors

**补充：第二范式的维基百科**

> 第二范式（2NF）是数据库正规化所使用的正规形式。规则是要求资料表里的所有资料都要和该资料表的键（主键与候选键）有**完全依赖**关系：每个非键属性必须独立于任意一个候选键的任意一部分属性。如果有哪些资料只和一个键的**一部分有关**的话，就得把它们**独立**出来变成另一个**资料表。(查询表)**

## 13. 第三范式

**第三范式的人话解释：**

> A column in a table should not be derived from other columns.
> 一个表中的字段不应该是由表中其他字段推导而来

例如，假设 invoices 发票表里现在有三个字段：发票额、支付额 和 余额，第三个可以由前两个相减得到所以不符合 3NF，每次前两者更新第三个就要随之更新，假设没有这样做，出现了 100，40，80 这样不一致的数据，就不知道到底该相信哪个了，余额到底是 80 还是 100-40=60？

同理，如果表里已经有 first_name 和 last_name 就不该有 full_name，因为第三者总是可以由前两者合并得到

不管是 余额balance 还是 全名fullname，都是一种冗余，应该删除

**补充：第三范式的维基百科**

> 第三范式（3NF）是数据库正规化所使用的正规形式，要求所有非主键属性都只和候选键有相关性，也就是说非主键属性之间应该是独立无关的。
> 如果再对第三范式做进一步加强就成了BC正规化，强调的重点在于“资料间的关系是奠基在主键上、以整个主键为考量、而且除了主键之外不考虑其他因素”。

**总结**

第三范式和前两范式一样，**都是为了减少数据重复和冗余，增强数据的一致性和完整性（data integrity）**

感觉三大范式可以用三个关键词总结：**单一值、单一功能、独立**

## 14. 我的实用建议

除非需要考试，不然没必要记忆和死板套用三大范式，实际工作中只需要专注于减少数据的重复性即可，比如发现一个 name 字段下出现的是一些重复的名字而不是重复的外键（如某种id），那就说明设计还不够归一化，**具体违反哪条范式并不重要，关键是专注于避免重复性**

**例子**

假设一个顾客表里每条都是一个顾客信息，有名字年龄生日性别还有收货地址，如果想让一个顾客可以有多条收货地址应该怎么办？

如果仍然把收货地址放在这个顾客表，就要为了保存一个顾客的多条地址而将这个顾客的所有信息复制多条，这是一种没必要的重复和冗余

我们先从概念和逻辑模型上思考，这里有两个关键实体，顾客 和 地址，它们是一对多关系，然后再细化为实体模型，应该建立两张表，顾客表保存顾客其他信息，地址表（实际上是顾客地址关系表）只保存顾客id和地址两个字段，这样就将重复性降到了最低

**小结**

总之，一定要先从概念和逻辑模型去考虑实体和关系，再逐步细化，过程中专注于避免数据的重复冗余以及保证数据的一致性和完整性，一定不要一上来就建表，这样几乎总是得到糟糕由混乱的数据库设计

**注意**

上面的例子以一个顾客有多个收货地址为前提，但如果一个顾客只有一个收货地址，那用一张表就足够了，用两张表是没必要的，所以关键是理解业务需求，总是按照业务需求来设计，这也引入了下一节内容：不要对全宇宙建模！

## 15. 不要对什么都建模

设计数据库时总是考虑当前的业务需求，不要试图包罗万象，总有开发人员会考虑各种未来可能出现的需求，实际上大部分那些需求都从未发生，反而使得数据库增加了很多没必要的复杂性，增加了查询的难度并拖慢了执行效率

Mosh之前的公司曾有个人设计了一个过于一般化但也过于复杂难懂的数据库，企图满足所有未来可能的需求，但结果是没人能懂他的模型，而且执行增删改查异常麻烦且速度极低，最后成了一个没人敢碰的烂摊子

建立复杂模型不是本事，能够将复杂的模型不断简化让其尽可能地优美简单易懂又能满足目前的需求，这才是本事，如果还能有不错的拓展性以满足未来可能的新特性就更好了

总之，尽可能保持简洁，**简洁才是终极哲学（Simplicity is the ultimate sophistication）**，无论你对未来的预测有多好，总会有意料之外的需求出现，总有一天你会写脚本改数据库甚至进行数据迁移，这是避免不了的，当前只需考虑如何最好地满足目前的需求就好了，不要企图对全宇宙建模

## 16. 正向搭建数据库

Forward Engineering a Model (2:35)

通过模型正向搭建数据库：workbench 菜单的 Database 选项 → Forward Engineer 正向搭建数据库

依据向导保持默认不断点下一步就好了，不要更改，除非你知道你在做什么

有一步可以选择 除了创建数据库中的表 是否还要创建 储存程序、触发器、事务和用户对象，而且表格可以筛选到底要创建哪些表

最后一步会展示对应的SQL代码，里面有创建 school 数据库（schema?）以及各表的SQL代码，之后会详细讲。可以选择保存代码为文件（以保存到仓库中）或者复制到剪贴板然后到 workbench 查询窗口里以脚本方式运行，这里我们直接运行，返回 local instance 链接刷新界面就可以看到新的 school 数据库和里面的6张表了

（？不过不知道问什么我的报错了，有些表没创建成功）

## 17. 使用数据库同步模型

之后可能会修改数据库结构，比如更改某些表中字段的数据类型或增加字段之类，如果只是自己一个人用的一个本地数据库，可以直接打开对应表的设计模式并点击更改即可，但如果是在团队中工作通常不是这样。

在中大型团队中，我们通常有多个服务器来模拟各种环境，其中有：
1. 生产环境（production environment）：用户真正访问应用和数据库的地方
2. 模拟环境（staging environment）：与生产环境十分接近
3. 测试环境（testing environment）：存粹用来做测试的
4. 开发环境（development environment）

每次需要对数据库做修改时我们需要复制相同的修改到不同的环境以保持数据的一致性

所以不能是在设计模式中直接点击修改，相反，是在之前的实体模型（EER Diagram）中修改并使用菜单中的 Database → Synchronize Model，其中有一步可以选择链接，这里我们选择本地连接 local_instance，但如果是在团队中可能需要选择测试环境、模拟环境甚至开发环境的链接以对相应环境中的数据库执行更改，MySQL会自动检测到需要修改的是 school 数据库并提示要修改的表，例如我们想在 enrollments 中加上一个 coupons 折扣券 字段，会提示将影响的表除了 enrollments 还有 courses 等表，因为这些表与要修改的表是相互关联的，之后的 SQL 的语句会先暂时删除相关外键以消除这些联系，对目标表做出相应更改（增加 coupons 字段）后再重建这些联系，同样的，我们可以把这些代码保存起来并上传到仓库，就可以在不同环境执行相同修改以保持一致性

## 18. 反向搭建数据库

如果要修改没有实体模型的数据库，第一次可以先逆向工程（Reverse Engineering）建立模型，之后每次就可以在该模型上修改了

例如，我们要修改 sql_store ，应如下操作：

1. 关闭当前 school 数据库的 Model，不然之后的逆向工程结果会添加到当前模型上，最好是每个数据库都有一个单独的模型，除非数据库间相互关联否者不要在一个模型中处理多个数据库
2. Database → Reverse Engineer，可以选择目标数据库，如上说所，除非数据库相互关联，否者最好一次只逆向工程一个数据库，让每个数据库都有一个单独的模型。
3. 同样，可以筛选要哪些表

在反向搭建出的模型中，可以更好的看清和理解数据库的结构设计，可以修改表结构，还可以发现问题，如在 sql_store 数据库的模型中，可以发现有一个 order_items_notes 表并未与任何表相联，这样里面的 order_id 就可能输入无效值，相反如果是建立了链接的表，MySQL会自动验证数据的一致性/完整性/有效性（integrity），只允许子表中添加父表中存在的id值

**小结**

第一次修改无模型的数据库可以使用MySQL自带的逆向工程，之后就可以用这个模型查看表结构、检查问题和进行修改

## 19. 项目：航班订票系统

通过一张机票上的信息理解航班订票业务需求并建立数据库模型

## 20. 解答：概念模型

Solution Conceptual Model (7:59)

主要建立**实体、实体里的字段、实体间的关系**，不用确定具体关系类型和字段类型等细节，主要用于和业务方交流

注意只根据机票信息决定需要的字段，满足当下需求就好，未来有新需求时再修改增加新的字段

![img](https://pic2.zhimg.com/80/v2-2d389a6a938e3c2e6793756229bd0fd1_720w.webp)

航班订票系统-概念模型

## 21. 解答：逻辑模型

与概念模型相比，逻辑模型主要做了如下细化调整：

1. **细化关系**，尤其是**多对多**关系，通常要另外添加链表变成两个多对一关系，**但是注意 flights 和 airports 的关系很特殊**，一个机场可对应多个航班但一个航班只能对应起飞和降落两个机场，是多对二的关系，或者说是两个多对一关系，如果还是通过一个链表来替换这个多对多关系，则不能防止一个航班出现多于两个机场，最好的办法是将 fights 中的机场区分为起飞机场id和降落机场id两个字段，分别建立外键引用airports（两个多对一连线？）
2. **调整字段**，name 这样的字段要**拆分**成 first_name 和 last_name 这样的更小组成成分，而**重复性**的字段常常要另外单独建表（查询表/资料表 lookup table）再以外键形式在原表中引用，但是 airports 里的 city 和 state 比较特殊，因为考虑到 city 和 state 与 airport经常一起查询，合并在一张表上能提高查询速度，而且机场数量并不多，重复性的问题并不严重，反而如果另外单独再建cities表和states表会使得数据**过于碎片化**，所以这里进行**“反归一化”（denormalize）**，在 airports 表中保留 city 和 state 的原始字段，**用一定的重复性来换取查询便利和效率**
3. **确认数据类型**，注意有的所谓的 number 其实不需做计算且包含符号，所以应该用字符串类型

另外注意用词和表达要向业务方咨询，确保用词准确表达方式与业务规范相一致，这很重要

还有注意调整字段时，可以将 flights 里的 duration 和 distance 改为 duration_in_minutes和 distance_in_miles，这样更明确，看的人不用去猜单位是什么

实体模型就不展示了，从逻辑模型到实体模型只是具体DBMS技术上的调整和实现，没必要反复讲

![img](https://pic1.zhimg.com/80/v2-6d10fa69b29e87ccb84b7c3427f561c4_720w.webp)

​                                                                       航班订票系统-逻辑模型

---

## 22. 项目：视频租赁应用

为视屏租赁应用Vidly建立数据库

## 23. 解答：概念模型

这一步还是一样，为了建立概念模型，根据业务需求文档确定大概的实体、实体属性、实体间关系

注意这里将顾客和电影的多对多关系细化为一个rentals链表（link table），变成可操作的两个一对多关系，这个方法之前也反复用到，如将学生和课程之间的关系细化为 enrollments 表 以及 乘客和航班的关系 细化为 tickets 表

![img](https://pic4.zhimg.com/80/v2-1c3e74aa8f33b7843af8badd75cb08ef_720w.webp)

​                                                                        视频租赁应用-概念模型

## 24. 解答：逻辑模型

如之前一样，在逻辑模型里，我们要确定数据储存方式，所以要进一步细化具体的实体间关系类型和字段的数据类型，也会为了减少数据重复性和提高数据一致性对表结构和数据库结构进行一些调整修改

**关系类型具体化和字段数据类型确定：**

和之前差不多，只是要注意 coupon 和 rental 的关系比较特殊，**是多对零或一（注意箭头的不同）**，因为一个 rental 可能有一个 coupon 也可能没有 coupon

**字段调整：**

将名字拆分为姓和名，将租赁天数拆分为借电影日期和还电影日期（后两个才能提供足够信息计算各月收入等）

**设计调整：**

之前的 users-permissions 用户-权限设计并不好，虽然业务文档确实提到了这两个实体，但仔细分析发现实际上用户只有两类 管理员和店员 而对应的权限唯一的区别也只是是否能修改电影列表，在这一业务情形下，没必要有一个完整的权限表将所有权限列出来，只需要有一个roles岗位表将用户分为两类即可，实际的权限可以通过if条件语句来根据用户是管理员还是店员来决定是否禁止其修改电影列表，这样的设计更精简，减少了每次增加一个用户就要挨个分配10个权限的重复性，也防止了给相同职位不同权限这样的错误的发生，增强了一致性

**思想**

没必要列出10个权限然后依次分配，以用户表-权限表的方式设计模型过于一般化，提供了业务并不需要的过高的控制等级，这种多余的复杂化和冗余会一直跟随系统一直造成不必要的麻烦。如果你有100元预算只想找个能歇脚能睡觉的地方，那一个500元的豪华宾馆多出的功能如高质量的网络漂亮的海景奢华的床铺等等对你来说都是没必要的，你不会多花400元买你不需要的功能，开发软件也一样， 所有功能和复杂性都是有成本的，都会有人买单，不要把公司的钱浪费在不需要的地方，要尽可能用最精简的方式满足当前的业务需求。

![img](https://pic4.zhimg.com/80/v2-26ae5dad7c73f9af91ccde2f4bd5dc5b_720w.webp)

​                                                                     视频租赁应用-逻辑模型

## 25. 创建和删除数据库

用 workbench 的向导来创建和修改数据库能够提高效率，但作为 DBA (Database Administrator 数据库管理员)，你必须要能理解并审核相关代码，确保其不会对数据库有不利影响，而且也有能力手动写代码完成创建和修改数据库的操作，可以不依赖工具。

```sql
CREATE DATABASE IF NOT EXISTS sql_store2;
DROP DATABASE IF EXISTS sql_store2
```

## 26. 创建表

以在 sql_store2 中建表 customers 为例，注意创建表之前还是要先用 USE 选择数据库，不然不知道你是要在哪个数据库中创建表

```sql
USE sql_store2;

DROP TABLE IF EXISTS customers;
CREAT TABLE customers
-- 没有就创建，有的话就推倒重建

或

CREATE TABLE IF NOT EXISTS customers
-- 没有就创建，有的话就不做改变

(
    -- 只挑选几个字段来建立
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50) NOT NULL, 
    points INT NOT NULL DEFAULT 0,
    email VARCHAR(255) NOT NULL UNIQUE
    -- UNIQUE 确保 email 值唯一，即每个用户的 email 必须不一样
)
```

**注意**

左侧栏导航窗口选择某表中的列时，下面的 Object Info 可以查看列的数据类型

**小结**

- 如上，创建对象（不管是数据库还是表）有两种方式，`DROP …… IF EXIXTS ……； CREAT ……` 和 `CREAT …… IF NOT EXISTS ……`，注意两种方式的区别在于，当原对象存在时，前者是推倒重建，后者是保持原状放弃创建
- 括号中设置列的方式为 `列名 数据类型 各种列性质`，列间逗号分隔，常用的列性质有 `PRIMARY KEY``NOT NULL``DEFAULT 0``UNIQUE`

## 27. 更改表

这节学习如何更改已存在的表，包括增删列和修改列类型和属性

```sql
USE sql_store2;
ALTER TABLE customers
    ADD [COLUMN] last_name VARCHAR(50) NOT NULL [AFTER first_name],
    ADD city VARCHAR(50) NOT NULL,
    MODIFY [COLUMN] first_name VARCHAR(60) DEFAULT '',
    DROP [COLUMN] points;
```

COLUMN 是可选的，有的人喜欢加上以增加可读性

AFTER first_name 是可选的，不加的话默认将新列添加到最后一列

MODIFY 修改已有列时其实感觉好像是是重置该列（= DROP + ADD），**所以注意要列出该列全部类型和属性信息**，如上例中将 first_name 修改为 VARCHAR(60) 类型并将默认值修改为空字符串''，但忘了加 NOT NULL，刷新后发现 first_name 不再有 NOT NULL 属性

列名最好不要有空格，但如果有的话可用反引号包裹，如 `last name`

**注意**

修改表永远不要直接在生产环境中进行，要首先在测试环境进行，确保没有错误和不良影响后再到生产环境进行修改

## 28. 创建关系

第26节在新的 store2 数据库中创建了 customers 表，这里我们接着创建 orders 表，并在表中添加 customer_id 外键来建立表间关系

```sql
CREATE DATABASE IF NOT EXISTS sql_store2;
USE sql_store2;
DROP TABLE IF EXISTS customers;
CREATE TABLE customers
(……);  
-- 在Workbench里可点击加减号来展开或收起代码块

DROP TABLE IF EXISTS orders;
CREATE TABLE orders
(
    order_id    INT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date  DATE NOT NULL,
    -- 在添加完所有列之后添加外键
    FOREIGN KEY fk_orders_customers (customer_id)
        REFERENCES customers (customer_id)
        ON UPDATE CASCADE
        -- 也有人主张用 NO ACTION / RESTRICT
        ON DELETE NO ACTION
        -- 禁止删除有订单的顾客
)
```

**外键名的命名习惯：**

```
fk（foreign key 的缩写）_子表名_父表名
```

**设置外键的语法结构：**

```sql
FOREIGN KEY 外键名 (外键字段)
        REFERENCES 父表 (主键字段)
        -- 设置外键约束：
        ON UPDATE CASCADE
        ON DELETE NO ACTION
```

**关于外键约束**

ON DELETE 设置为 NO ACTION / RESTRICT 可以防止删除有的订单的顾客，这没什么问题；而对于 ON UPDATE，也有人主张同样应该设为 NO ACTION / RESTRICT，因为主键是永远不应该被更改的，理论上Mosh支持这个观点，但实际世界并不完美，由于意外或系统错误等原因，主键是有可能改变的，所以Mosh一般设置为CASCADE，让外键随着主键的更改而更改，但你要设置为 NO ACTION / RESTRICT 也同样有道理。另外，想查看外键约束的可选项以及想通过菜单选择来更改外键约束的话，可以打开某列的设计模式，在 Foreign Keys 标签页里进行选择

**表间依赖**

还有注意一点，运行以上SQL文件从头创建 sql_store2数据库以及customers和orders两张表时，第一次运行没问题，但要再次运行的化会报以下错误：

```sql
/* Error Code: 1217. Cannot delete or update a parent row: 
a foreign key constraint fails*/
```

这是因为建立主外键关系后， customers 现在和 orders 是父子表，orders 表**依赖于** customers 表，所以必须先删除 orders 表才能删除 customers 表，所以应该把 orders 表的 DROP 语句放到最前面：

```sql
CREATE DATABASE IF NOT EXISTS sql_store2;
USE sql_store2;
-- 删表时先删子表
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS customers;

-- 建表时先建父表（我觉得应该是）
CREATE TABLE customers
(……);

CREATE TABLE orders
(……);
```

这样运行再多次也没问题了，总是可以从头建立sql_store2数据库和customers、orders两张表 （不过为什么不在最开头创建数据库的语句里用 `DROP DATABASE IF EXISTS sql_store2; CREATE DATABASE sql_store2` 这种直接将整个数据库推倒重建的方式呢？）

## 29. 更改主键和外键约束

这一节学习如何在已经存在的表间创建和删除关系，还是用 `ALTER TABLE` 语句 + `ADD`、`DROP` 关键词，和27节修改表里一样，只不过这里增删的是不是列而是外键：

```sql
USE sql_store2;
ALTER TABLE orders 
    DROP FOREIGN KEY fk_orders_customers,  -- orders_ibfk_1
    ADD FOREIGN KEY fk_orders_customers (customer_id)
        REFERENCES customers (customer_id)
        ON UPDATE CASCADE
        ON DELETE NO ACTION;
```

**注意**

不知道为什么，我这里不管是之前第28节创建orders表时设置外键还是这里通过修改ADD增加外键，外键名明明写的是 `fk_orders_customers`，实际上都会变成 `orders_ibfk_1`，要去设计模式手动修改才行，可能是bug

另外也可以通过类似的 ALTER TABLE 语句增删主键：

```sql
USE sql_store2;
ALTER TABLE orders
    ADD PRIMARY KEY (order_id,……,……),
    -- 可设置多个主键，在括号内用逗号隔开
    DROP PRIMARY KEY;
    -- 删除主键不用声明，会直接删除所有主键
```

另外，像增删主键这种既可以用菜单点击也可以用代码运行实现的操作（Workbench里这种操作相当多了），当忘记相关SQL代码写法时，可以通过菜单点击方式操作然后在 Review the SQL script 那一步看一看，就知道代码怎么写的了

## 30. 字符集和排序规则

字符是以数字序列的形式储存于电脑中的，字符集是数字序列与字符相互转换的字典，不同的字符集支持不同的字符范围，有些支持拉美语言字符，有些也支持亚洲语言字符，有些支持全世界所有字符，查看MySQL支持的所有字符集：

```sql
SHOW CHARSET;
```

其中 armscii8 支持亚美尼亚语，big5 支持繁体中文，gb2312 和 gbk 支持简体中文，而 utf-8支持全世界的语言，utf-8 也是MySQL自版本5之后的默认字符集。

还可以看到字符集描述，默认排序规则，最大长度

排序规则（collation n. 校对，整理，排序规则）指的是某语言内字符的排序方式，utf-8 的默认排序规则是 utf8_general_ci，其中 ci 表示 case insensitive 大小写不敏感，即MySQL在排序时不会区分大小写，这在大部分时候都是适用的，比如用户输入名字的时候大小写不固定，我们希望只按照字符顺序而不管大小写来对名字进行排序。总之，99.9% 的情况下都不需要更改默认排序规则。

最大长度指的是对该字符集来说，给每个字符预留的最大字节数，如 latin1 是 1 字节，utf-8 就是 3 Byte，前面说过，在utf-8里，拉丁字符使用 1 字节，欧洲和中东字符使用 2 字节，亚洲语言的字符使用 3 字节，所以 utf-8 给每个字符预留 3 字节。

对于字符集来说，大部分时候用默认的 utf-8 就行了。但有时，我们可以通过更改字符集来减少空间占用，例如，我们某个特定的应用（对应的数据库）/特定表/特定列是只能输入英文字符的，那如果将该列的字符集从 utf-8 改为 latin1，占用空间就会缩小到原来的 1/3，以字段类型为 CHAR(10)（固定预留10个字符）且有 1 百万条记录为例，占用空间就会从约 30MB 减到 10MB。接下来讲如何用菜单和代码方式更改库/表/列的字符集。

**菜单方式更改字符集**

右键 sql_store2 数据库，点击 Schema Inspector，可以查看整个数据库以及各表各列的字符集和排序规则，Schema Inspector 也能查看该数据库的主键外键、视图、触发器、储存程序、事务、函数等各方面情况

要修改库或者表和列的字符集，直接点开库或者表的设计模式（扳手按钮）在里面选择更改即可，一般我们会让表和列的字符集和整个库保持一致，毕竟一个应用要不然是国际化的要不然就不是。

**代码方式更改字符集**

总的来说就是将设置字符集的语句 `CHARACTER SET 字符集名` 加在之前那些创建/更改数据库/表/列语句的合适位置即可

1. 在创建或修改数据库时设置或修改数据库的字符集

```sql
CREATE/ALTER DATABASE db_name 
    CHARACTER SET latin1
```

2. 在创建或修改表时设置或修改表的字符集

```sql
CREATE/ALTER TABLE table1
(……) 
CHARACTER SET latin1
```

3. 在创建或修改表时设置或修改列的字符集

就是将 `CHARACTER SET latin1` 加在列设置语句的**字段类型和字段属性之间**

```sql
CREATE TABLE IF NOT EXISTS customers
(
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50) CHARACTER SET latin1 NOT NULL, 
    points INT NOT NULL DEFAULT 0,
    email VARCHAR(255) NOT NULL UNIQUE
)

或

USE sql_store2;
ALTER TABLE customers
    MODIFY first_name VARCHAR(50) CHARACTER SET latin1 NOT NULL,
    ADD    last_name  VARCHAR(50) CHARACTER SET latin1 NOT NULL AFTER first_name;
```

## 31. 存储引擎

在MySQL中我们有若干种储存引擎，储存引擎决定了我们数据的**储存方式以及可用的功能**

展示可用的储存引擎：

```sql
SHOW ENGINES;
```

储存引擎有很多，我们真正需要知道只有两个：MyISAM 和 InnoDB

MyISAM 是曾经很流行的引擎，但自 MySQL5.5 之后，默认引擎就改为 InnoDB了，InnoDB支持更多的功能特性，包括事务、外键等等，所以最好使用 InnoDB

引擎是表层级的设置，每个表都可以设置不同的引擎（虽然这没必要）

外键是十分重要的，它可以增加引用一致性/完整性（referential integrity），如果我们有一个老数据库的引擎是MyISAM，我们想要给它设置外键，就必须要将其引擎升级为InnoDB，可以在表的设计模式里选择更改，也可以用修改表的代码：

```sql
ALTER TABLE customers
ENGINE = InnoDB;
```

**注意**

改变引擎是一个代价极高（expensive）的操作，它会重建整个表，在此期间无法方法访问数据。所以，除非有特殊的理由，不然不要在生产环境中改变储存引擎